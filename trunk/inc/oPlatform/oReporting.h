// $(header)
// This header describes the configurable handler for generated by oASSERT 
// macros. Highlights include a stack onto which the user can push their own
// report handler and a filter mechanism to ignore oASSERTs by ID.
#pragma once
#ifndef oReporting_h
#define oReporting_h

#include <oBasis/oAssert.h>

struct oREPORTING_DESC
{
	oREPORTING_DESC()
		: LogFilePath(nullptr)
		, PromptAsserts(true)
		, PromptWarnings(true)
		, PrintCallstack(true)
		, PrefixFileLine(true)
		, PrefixThreadId(true)
		, PrefixMsgType(true)
		, PrefixMsgId(false)
	{}

	// If specified and a valid, accessible file path, all output through this 
	// error system will be written to the specified file. The specified string
	// will be copied and retained internally, so it is safe to free the buffer
	// that is being pointed to by this struct once the DESC has been set.
	const char* LogFilePath;
	bool PromptAsserts;
	bool PromptWarnings;
	bool PrintCallstack;
	bool PrefixFileLine;
	bool PrefixThreadId;
	bool PrefixMsgType;
	bool PrefixMsgId;
};

typedef oASSERT_ACTION (*oReportingVPrint)(const oASSERTION& _Assertion, void* _hLogFile, const char* _Format, va_list _Args);

// Some objects use reporting in init/deinit, and those objects might be part of
// static init/deinit. To ensure oReporting resources are available during that
// time, have the objects call oReportingReference() and then 
// oReportingRelease() when finished.
void oReportingReference();
void oReportingRelease();

// Configure and inspect the reporting mechanism that translates oASSERTs and 
// into logs, debug spew, and message prompts.
void oReportingSetDesc(const oREPORTING_DESC& _Desc);
void oReportingGetDesc(oREPORTING_DESC* _pDesc);

// Push and pops a user ReportV function. By default there is a very low-level 
// reporting system at the base used during early bootstrap and a more robust 
// reporting system that is pushed when all prerequisits are initialized. This 
// can return false if the push fails because the stack is full.
bool oReportingPushReporter(oReportingVPrint _Reporter);
oReportingVPrint oReportingPopReporter();

// A reporting filter prevents assertions matching the ID from being reported.
void oReportingAddFilter(size_t _AssertionID);
void oReportingRemoveFilter(size_t _AssertionID);

#endif
